<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Playing Cards Simulation</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
        #cardPreview {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 200px;
            display: none;
            background: white;
            padding: 5px;
            z-index: 100;
        }
    </style>
</head>
<body>

<img id="cardPreview" alt="Card Preview">

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/peerjs@1.3.1/dist/peerjs.min.js"></script>


<script>
    let scene, camera, renderer, world, raycaster, mouse, selectedCard = null, dragOffset = new THREE.Vector3();
    let cards = [], cardBodies = [], cardTextures = [];
    let keys = {};
    let tiltSpeed = 0.1;
    const minZoom = 3;
    const maxZoom = 10;
    const cardPreview = document.getElementById('cardPreview'); 
    let peer, currentPeerId, connections = {};

    function init() {
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0xffffff);

        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 5, 10);
        camera.lookAt(0, 0, 0);

        renderer = new THREE.WebGLRenderer({ antialias: false, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1));
        document.body.appendChild(renderer.domElement);

        world = new CANNON.World();
        world.gravity.set(0, -9.82, 0);

        let groundShape = new CANNON.Plane();
        let groundBody = new CANNON.Body({
            mass: 0,
            shape: groundShape,
            position: new CANNON.Vec3(0, 0, 0)
        });
        groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
        world.addBody(groundBody);

        let groundGeometry = new THREE.PlaneGeometry(50, 50);
        let groundMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide });
        let ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = Math.PI / 2;
        scene.add(ground);

        let ceilingGeometry = new THREE.PlaneGeometry(50, 50);
        let ceilingMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide });
        let ceiling = new THREE.Mesh(ceilingGeometry, ceilingMaterial);
        ceiling.position.y = 10; // Place ceiling above the cards
        ceiling.rotation.x = Math.PI / 2;
        scene.add(ceiling);

        raycaster = new THREE.Raycaster();
        mouse = new THREE.Vector2();

        createCard(0, 3, 0);
        createCard(1, 5, -1);
        createCard(-2, 4, 2);

        // Initialize PeerJS
        peer = new Peer();
        peer.on('open', id => {
            currentPeerId = id;
            console.log(`Your Peer ID: ${id}`);
            promptPeerConnection();
        });
        
        peer.on('connection', conn => {
            conn.on('data', data => {
                handleReceivedData(data);
            });
            connections[conn.peer] = conn;
        });

        window.addEventListener('mousedown', onMouseDown);
        window.addEventListener('mousemove', onMouseMove);
        window.addEventListener('mouseup', onMouseUp);
        window.addEventListener('keydown', onKeyDown);
        window.addEventListener('keyup', onKeyUp);
        window.addEventListener('mousemove', onMouseMoveTilt);
        window.addEventListener('wheel', onMouseWheel); // Added scroll for zooming

        window.addEventListener('resize', () => {
            renderer.setSize(window.innerWidth, window.innerHeight);
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
        });

        animate();
    }

    function promptPeerConnection() {
        const otherPeerId = prompt("Enter Peer ID to connect:");
        if (otherPeerId) {
            const conn = peer.connect(otherPeerId);
            conn.on('open', () => {
                connections[otherPeerId] = conn;
            });
        }
    }

    function createCard(x, y, z) {
        let cardShape = new CANNON.Box(new CANNON.Vec3(1, 0.01, 1.5));
        let cardBody = new CANNON.Body({ mass: 1 });
        cardBody.addShape(cardShape);
        cardBody.position.set(x, y, z);
        world.addBody(cardBody);
        cardBodies.push(cardBody);

        let textureLoader = new THREE.TextureLoader();
        let cardTexture = textureLoader.load('https://cards.scryfall.io/large/front/2/f/2f5500a2-c6d6-40d7-b586-59b854733160.jpg?1562393909');
        
        cardTextures.push('https://cards.scryfall.io/large/front/2/f/2f5500a2-c6d6-40d7-b586-59b854733160.jpg?1562393909');

        let cardGeometry = new THREE.BoxGeometry(2, 0.02, 3);
        let cardMaterial = new THREE.MeshBasicMaterial({ map: cardTexture, transparent: true });
        let card = new THREE.Mesh(cardGeometry, cardMaterial);
        scene.add(card);
        cards.push(card);
    }

    let lastTime;
    function animate(time) {
        if (lastTime !== undefined) {
            const deltaTime = (time - lastTime) / 1000;
            world.step(1 / 30, deltaTime);
        }
        lastTime = time;

        updateCards();
        moveCamera();
        renderer.render(scene, camera);

        requestAnimationFrame(animate);
    }

    function handleReceivedData(data) {
        if (data.type === 'moveCard') {
            const { cardId, newPosition } = data.payload;
            const index = cards.findIndex(card => card.id === cardId);
            if (index >= 0) {
                cardBodies[index].position.copy(newPosition);
                cards[index].position.copy(newPosition);
            }
        }
    }

    function moveCard(cardId, newPosition) {
        const data = { type: 'moveCard', payload: { cardId, newPosition } };
        for (const conn of Object.values(connections)) {
            conn.send(data);
        }
    }

    function updateCards() {
        for (let i = 0; i < cards.length; i++) {
            cards[i].position.copy(cardBodies[i].position);
            cards[i].quaternion.copy(cardBodies[i].quaternion);
        }
    }

    function moveCamera() {
        const speed = 0.1; // Adjust speed as necessary
        if (keys['w']) camera.position.z -= speed;
        if (keys['s']) camera.position.z += speed;
        if (keys['a']) camera.position.x -= speed;
        if (keys['d']) camera.position.x += speed;

        // Limit zoom height
        if (camera.position.y < minZoom) camera.position.y = minZoom;
        if (camera.position.y > maxZoom) camera.position.y = maxZoom;
    }

    function onMouseDown(event) {
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

        raycaster.setFromCamera(mouse, camera);

        let intersects = raycaster.intersectObjects(cards);
        if (intersects.length > 0) {
            let intersect = intersects[0];
            selectedCard = intersect.object;

            let index = cards.indexOf(selectedCard);
            let cardBody = cardBodies[index];

            dragOffset.copy(intersect.point).sub(cardBody.position);
            cardBody.mass = 0;
        }
    }

    function onMouseMove(event) {
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

        raycaster.setFromCamera(mouse, camera);

        let intersects = raycaster.intersectObjects(cards);
        if (intersects.length > 0) {
            let intersect = intersects[0];
            let index = cards.indexOf(intersect.object);
            // Show high-res card texture in the preview
            cardPreview.src = cardTextures[index];
            cardPreview.style.display = 'block';
        } else {
            cardPreview.style.display = 'none';
        }

        if (selectedCard) {
            let plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), -selectedCard.position.y);
            let intersection = new THREE.Vector3();
            raycaster.ray.intersectPlane(plane, intersection);

            let index = cards.indexOf(selectedCard);
            let cardBody = cardBodies[index];

            cardBody.position.copy(intersection.sub(dragOffset));
            moveCard(selectedCard.id, cardBody.position); // Send move to peers
        }
    }

    function onMouseUp() {
        if (selectedCard) {
            let index = cards.indexOf(selectedCard);
            let cardBody = cardBodies[index];
            cardBody.mass = 1; 
            selectedCard = null;
        }
    }

    function onKeyDown(event) {
        keys[event.key] = true;
    }

    function onKeyUp(event) {
        keys[event.key] = false;
    }

    function onMouseWheel(event) {
        event.preventDefault();
        const zoomAmount = event.deltaY * 0.01;
        camera.position.y += zoomAmount;
    }

    function onMouseMoveTilt(event) {
        const width = window.innerWidth;
        const height = window.innerHeight;

        const mouseX = (event.clientX / width) * 2 - 1;
        const mouseY = (event.clientY / height) * 2 - 1;

        const tiltAmountX = -mouseY * tiltSpeed;
        const tiltAmountY = -mouseX * tiltSpeed;
        camera.rotation.x += tiltAmountX;
        camera.rotation.y += tiltAmountY;
    }

    init();
</script>

</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Playing Cards Simulation</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
        #cardPreview {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 200px;
            display: none;
            background: transparent;
            padding: 5px;
            z-index: 100;
        }
    </style>
</head>
<body>

<img id="cardPreview" alt="Card Preview">

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/peerjs@1.3.1/dist/peerjs.min.js"></script>


<script>
    let scene, camera, renderer, world, raycaster, mouse, selectedCard = null, dragOffset = new THREE.Vector3();
    let cards = [], cardBodies = [], cardTextures = [];
    let keys = {};
    let tiltSpeed = 0.1;
    const minZoom = 4;
    const maxZoom = 19;
    const cardPreview = document.getElementById('cardPreview'); 
    let peer, currentPeerId, connections = {};

    function init() {
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0xffffff);

        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 5, 10);
        camera.lookAt(0, 0, 0);

        renderer = new THREE.WebGLRenderer({ antialias: false, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1));
        document.body.appendChild(renderer.domElement);

        world = new CANNON.World();
        world.gravity.set(0, -9.82, 0);

        let groundShape = new CANNON.Plane();
        let groundBody = new CANNON.Body({
            mass: 0,
            shape: groundShape,
            position: new CANNON.Vec3(0, 0, 0)
        });
        groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
        world.addBody(groundBody);

        let groundGeometry = new THREE.PlaneGeometry(50, 50);
        let groundMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide });
        let ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = Math.PI / 2;
        scene.add(ground);

        let ceilingGeometry = new THREE.PlaneGeometry(50, 50);
        let ceilingMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide });
        let ceiling = new THREE.Mesh(ceilingGeometry, ceilingMaterial);
        ceiling.position.y = 20;
        ceiling.rotation.x = Math.PI / 2;
        scene.add(ceiling);

        raycaster = new THREE.Raycaster();
        mouse = new THREE.Vector2();

        createCard(0, 3, 0);
        createCard(1, 5, -1);
        createCard(-2, 4, 2);

        peer = new Peer();
        peer.on('open', id => {
            currentPeerId = id;
            console.log(`Your Peer ID: ${id}`);
            promptPeerConnection();
        });
        
        peer.on('connection', conn => {
            conn.on('data', data => {
                handleReceivedData(data);
            });
            connections[conn.peer] = conn;
        });

        window.addEventListener('mousedown', onMouseDown);
        window.addEventListener('mousemove', onMouseMove);
        window.addEventListener('mouseup', onMouseUp);
        window.addEventListener('keydown', onKeyDown);
        window.addEventListener('keyup', onKeyUp);
        window.addEventListener('mousemove', onMouseMoveTilt);
        window.addEventListener('wheel', onMouseWheel);

        window.addEventListener('resize', () => {
            renderer.setSize(window.innerWidth, window.innerHeight);
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
        });

        animate();
    }

    function promptPeerConnection() {
        const otherPeerId = prompt("Enter Peer ID to connect:");
        if (otherPeerId) {
            const conn = peer.connect(otherPeerId);
            conn.on('open', () => {
                connections[otherPeerId] = conn;
            });
        }
    }

    function createCard(x, y, z) {
        let cardShape = new CANNON.Box(new CANNON.Vec3(1, 0.01, 1.5));
        let cardBody = new CANNON.Body({ mass: 1 });
        cardBody.addShape(cardShape);
        cardBody.position.set(x, y, z);
        world.addBody(cardBody);
        cardBodies.push(cardBody);

        let textureLoader = new THREE.TextureLoader();
        let cardTexture = textureLoader.load('https://cards.scryfall.io/large/front/2/f/2f5500a2-c6d6-40d7-b586-59b854733160.jpg?1562393909');
        
        cardTextures.push('https://cards.scryfall.io/large/front/2/f/2f5500a2-c6d6-40d7-b586-59b854733160.jpg?1562393909');

        let cardGeometry = new THREE.BoxGeometry(2, 0.02, 3);
        let cardMaterial = new THREE.MeshBasicMaterial({ map: cardTexture, transparent: true });
        let card = new THREE.Mesh(cardGeometry, cardMaterial);
        scene.add(card);
        cards.push(card);
    }

    let lastTime;
    function animate(time) {
        if (lastTime !== undefined) {
            const deltaTime = (time - lastTime) / 1000;
            world.step(1 / 30, deltaTime);
        }
        lastTime = time;

        updateCards();
        moveCamera();
        renderer.render(scene, camera);

        requestAnimationFrame(animate);
    }

    function handleReceivedData(data) {
        if (data.type === 'moveCard') {
            const { cardId, newPosition } = data.payload;
            const index = cards.findIndex(card => card.id === cardId);
            if (index >= 0) {
                cardBodies[index].position.copy(newPosition);
                cards[index].position.copy(newPosition);
            }
        }
    }

    function moveCard(cardId, newPosition) {
        const data = { type: 'moveCard', payload: { cardId, newPosition } };
        for (const conn of Object.values(connections)) {
            conn.send(data);
        }
    }

    function updateCards() {
        for (let i = 0; i < cards.length; i++) {
            cards[i].position.copy(cardBodies[i].position);
            cards[i].quaternion.copy(cardBodies[i].quaternion);
        }
    }

    function moveCamera() {
        const speed = 0.1;
        if (keys['w']) camera.position.z -= speed;
        if (keys['s']) camera.position.z += speed;
        if (keys['a']) camera.position.x -= speed;
        if (keys['d']) camera.position.x += speed;

        if (camera.position.y < minZoom) camera.position.y = minZoom;
        if (camera.position.y > maxZoom) camera.position.y = maxZoom;
    }

    function onMouseDown(event) {
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

        raycaster.setFromCamera(mouse, camera);

        let intersects = raycaster.intersectObjects(cards);
        if (intersects.length > 0) {
            let intersect = intersects[0];
            selectedCard = intersect.object;

            let index = cards.indexOf(selectedCard);
            let cardBody = cardBodies[index];

            dragOffset.copy(intersect.point).sub(cardBody.position);
            cardBody.mass = 0;
        }
    }

    function onMouseMove(event) {
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

        raycaster.setFromCamera(mouse, camera);

        let intersects = raycaster.intersectObjects(cards);
        if (intersects.length > 0) {
            let intersect = intersects[0];
            let index = cards.indexOf(intersect.object);

            cardPreview.src = cardTextures[index];
            cardPreview.style.display = 'block';
        } else {
            cardPreview.style.display = 'none';
        }

        if (selectedCard) {
            let plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), -selectedCard.position.y);
            let intersection = new THREE.Vector3();
            raycaster.ray.intersectPlane(plane, intersection);

            let index = cards.indexOf(selectedCard);
            let cardBody = cardBodies[index];

            cardBody.position.copy(intersection.sub(dragOffset));
            moveCard(selectedCard.id, cardBody.position);
        }
    }

    function onMouseUp() {
        if (selectedCard) {
            let index = cards.indexOf(selectedCard);
            let cardBody = cardBodies[index];
            cardBody.mass = 1; 
            selectedCard = null;
        }
    }

    function onKeyDown(event) {
        keys[event.key] = true;
    }

    function onKeyUp(event) {
        keys[event.key] = false;
    }

    function onMouseWheel(event) {
        event.preventDefault();
        const zoomAmount = event.deltaY * 0.01;
        camera.position.y += zoomAmount;
    }

    function onMouseMoveTilt(event) {
        const width = window.innerWidth;
        const height = window.innerHeight;

        const mouseX = (event.clientX / width) * 2 - 1;
        const mouseY = (event.clientY / height) * 2 - 1;

        const tiltAmountX = -mouseY * tiltSpeed;
        const tiltAmountY = -mouseX * tiltSpeed;
        camera.rotation.x += tiltAmountX;
        camera.rotation.y += tiltAmountY;
    }

    init();
</script>

</body>
</html>
